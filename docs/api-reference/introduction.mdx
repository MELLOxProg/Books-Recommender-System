---
title: 'API Documentation'
description: 'Learn how to integrate with the Book Recommender System programmatically'
---

## API Overview

The Book Recommender System provides a programmatic interface for generating book recommendations using collaborative filtering. While the primary interface is through the Streamlit web application, you can also integrate the recommendation engine directly into your own applications.

<Note>
  The current system is designed as a standalone application. For production API usage, consider wrapping the core functions in a REST API framework like FastAPI or Flask.
</Note>

## Core Functions

### Recommendation Engine

The heart of the system is the `recommend_book()` function that provides book suggestions:

```python path=/app.py start=39
def recommend_book(book_name):
    """
    Generate book recommendations using k-NN collaborative filtering
    
    Args:
        book_name (str): Title of the book to base recommendations on
        
    Returns:
        tuple: (book_list, poster_urls)
            - book_list: List of 6 recommended book titles (including input)
            - poster_urls: List of 6 corresponding book cover image URLs
    """
    books_list = []
    
    # Find book index in the pivot table
    book_id = np.where(book_pivot.index == book_name)[0][0]
    
    # Get book's rating vector
    book_vector = book_pivot.iloc[book_id, :].values.reshape(1, -1)
    
    # Find k nearest neighbors
    distances, suggestions = model.kneighbors(book_vector, n_neighbors=6)
    
    # Get poster URLs
    poster_urls = fetch_poster(suggestions)
    
    # Extract book titles
    for i in range(len(suggestions[0])):
        book_indices = suggestions[0][i]
        books = book_pivot.index[book_indices]
        for book in books:
            books_list.append(book)
    
    return books_list, poster_urls
```

### Image Retrieval

The `fetch_poster()` function retrieves book cover images:

```python path=/app.py start=19
def fetch_poster(suggestions):
    """
    Fetch book cover URLs for recommended books
    
    Args:
        suggestions: k-NN model output containing book indices
        
    Returns:
        list: URLs of book cover images
    """
    book_names = []
    ids_index = []
    poster_urls = []
    
    # Get book names from indices
    for book_id in suggestions[0]:
        book_names.append(book_pivot.index[book_id])
    
    # Find corresponding entries in rating dataset
    for name in book_names:
        ids = np.where(final_rating['title'] == name)[0][0]
        ids_index.append(ids)
    
    # Extract image URLs
    for idx in ids_index:
        url = final_rating.iloc[idx]['image_url']
        poster_urls.append(url)
    
    return poster_urls
```

## Integration Examples

### Python Integration

<Tabs>
  <Tab title="Direct Integration">
    ```python path=null start=null
    import pickle
    import numpy as np
    
    class BookRecommender:
        """Wrapper class for the book recommendation system"""
        
        def __init__(self, artifacts_path='artifacts/'):
            """Initialize the recommender with model artifacts"""
            self.artifacts_path = artifacts_path
            self.load_models()
        
        def load_models(self):
            """Load all required model artifacts"""
            try:
                self.model = pickle.load(open(f'{self.artifacts_path}model.pkl', 'rb'))
                self.book_names = pickle.load(open(f'{self.artifacts_path}book_names.pkl', 'rb'))
                self.book_pivot = pickle.load(open(f'{self.artifacts_path}book_pivot.pkl', 'rb'))
                self.final_rating = pickle.load(open(f'{self.artifacts_path}final_rating.pkl', 'rb'))
                print(f"Loaded {len(self.book_names)} books successfully")
            except FileNotFoundError as e:
                raise Exception(f"Model artifacts not found: {e}")
        
        def get_recommendations(self, book_name, num_recommendations=5):
            """
            Get book recommendations
            
            Args:
                book_name (str): Name of the book
                num_recommendations (int): Number of recommendations to return
                
            Returns:
                dict: Recommendations with metadata
            """
            if book_name not in self.book_pivot.index:
                return {'error': f'Book "{book_name}" not found in dataset'}
            
            try:
                # Get book recommendations
                book_id = np.where(self.book_pivot.index == book_name)[0][0]
                book_vector = self.book_pivot.iloc[book_id, :].values.reshape(1, -1)
                
                distances, suggestions = self.model.kneighbors(
                    book_vector, 
                    n_neighbors=num_recommendations + 1  # +1 to include input book
                )
                
                # Extract recommendations (excluding the input book)
                recommendations = []
                for i in range(1, len(suggestions[0])):  # Skip index 0 (input book)
                    book_idx = suggestions[0][i]
                    recommended_book = self.book_pivot.index[book_idx]
                    
                    # Get additional metadata
                    book_info = self.final_rating[
                        self.final_rating['title'] == recommended_book
                    ].iloc[0]
                    
                    recommendations.append({
                        'title': book_info['Book-Title'],
                        'author': book_info['Book-Author'],
                        'similarity_score': 1 - distances[0][i],  # Convert distance to similarity
                        'image_url': book_info.get('Image-URL-M', ''),
                        'isbn': book_info.get('ISBN', '')
                    })
                
                return {
                    'input_book': book_name,
                    'recommendations': recommendations,
                    'total_found': len(recommendations)
                }
                
            except Exception as e:
                return {'error': f'Error generating recommendations: {str(e)}'}
        
        def get_book_info(self, book_name):
            """Get detailed information about a specific book"""
            if book_name not in self.book_pivot.index:
                return {'error': f'Book "{book_name}" not found'}
            
            book_data = self.final_rating[
                self.final_rating['title'] == book_name
            ].iloc[0]
            
            return {
                'title': book_data['Book-Title'],
                'author': book_data['Book-Author'],
                'publisher': book_data.get('Publisher', 'Unknown'),
                'year': book_data.get('Year-Of-Publication', 'Unknown'),
                'isbn': book_data.get('ISBN', ''),
                'image_url': book_data.get('Image-URL-M', ''),
                'average_rating': self.book_pivot.loc[book_name].mean(),
                'total_ratings': (self.book_pivot.loc[book_name] > 0).sum()
            }
        
        def search_books(self, query, limit=10):
            """Search for books by title"""
            query_lower = query.lower()
            matches = [
                book for book in self.book_names 
                if query_lower in book.lower()
            ]
            return matches[:limit]
    
    # Usage example
    recommender = BookRecommender()
    
    # Get recommendations
    result = recommender.get_recommendations("harry potter and the philosopher's stone")
    print(f"Found {result['total_found']} recommendations")
    
    for i, book in enumerate(result['recommendations'], 1):
        print(f"{i}. {book['title']} by {book['author']} (similarity: {book['similarity_score']:.3f})")
    ```
  </Tab>

  <Tab title="Batch Processing">
    ```python path=null start=null
    import pandas as pd
    from concurrent.futures import ThreadPoolExecutor
    import json
    
    class BatchRecommender(BookRecommender):
        """Extended recommender for batch processing"""
        
        def batch_recommendations(self, book_list, num_recommendations=5, max_workers=4):
            """
            Generate recommendations for multiple books in parallel
            
            Args:
                book_list (list): List of book names
                num_recommendations (int): Number of recommendations per book
                max_workers (int): Number of parallel threads
                
            Returns:
                dict: Results for all books
            """
            def get_single_recommendation(book_name):
                return {
                    'book': book_name,
                    'result': self.get_recommendations(book_name, num_recommendations)
                }
            
            results = {}
            
            with ThreadPoolExecutor(max_workers=max_workers) as executor:
                future_to_book = {
                    executor.submit(get_single_recommendation, book): book 
                    for book in book_list
                }
                
                for future in future_to_book:
                    book_name = future_to_book[future]
                    try:
                        result = future.result()
                        results[book_name] = result['result']
                    except Exception as e:
                        results[book_name] = {'error': str(e)}
            
            return results
        
        def export_recommendations(self, results, output_file='recommendations.json'):
            """Export recommendation results to JSON file"""
            with open(output_file, 'w') as f:
                json.dump(results, f, indent=2, default=str)
            
            print(f"Results exported to {output_file}")
        
        def create_recommendation_report(self, book_list):
            """Generate a comprehensive recommendation report"""
            results = self.batch_recommendations(book_list)
            
            # Create summary statistics
            successful_recs = sum(1 for r in results.values() if 'recommendations' in r)
            failed_recs = len(results) - successful_recs
            
            report = {
                'summary': {
                    'total_books': len(book_list),
                    'successful_recommendations': successful_recs,
                    'failed_recommendations': failed_recs,
                    'success_rate': successful_recs / len(book_list) * 100
                },
                'results': results,
                'generated_at': pd.Timestamp.now().isoformat()
            }
            
            return report
    
    # Usage example
    batch_recommender = BatchRecommender()
    
    # Process multiple books
    books_to_process = [
        "1984",
        "to kill a mockingbird", 
        "the great gatsby",
        "pride and prejudice"
    ]
    
    # Generate report
    report = batch_recommender.create_recommendation_report(books_to_process)
    
    print(f"Success rate: {report['summary']['success_rate']:.1f}%")
    batch_recommender.export_recommendations(report)
    ```
  </Tab>
</Tabs>

### REST API Wrapper

Create a REST API wrapper using FastAPI:

```python path=null start=null
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List, Optional
import uvicorn

app = FastAPI(
    title="Book Recommender API",
    description="API for generating book recommendations using collaborative filtering",
    version="1.0.0"
)

# Initialize recommender
recommender = BookRecommender()

class RecommendationRequest(BaseModel):
    book_name: str
    num_recommendations: Optional[int] = 5

class BookInfo(BaseModel):
    title: str
    author: str
    similarity_score: float
    image_url: str
    isbn: str

class RecommendationResponse(BaseModel):
    input_book: str
    recommendations: List[BookInfo]
    total_found: int

@app.get("/")
async def root():
    return {"message": "Book Recommender API", "version": "1.0.0"}

@app.get("/books/search")
async def search_books(q: str, limit: int = 10):
    """Search for books by title"""
    results = recommender.search_books(q, limit)
    return {"query": q, "results": results, "count": len(results)}

@app.post("/recommendations", response_model=RecommendationResponse)
async def get_recommendations(request: RecommendationRequest):
    """Get book recommendations"""
    result = recommender.get_recommendations(
        request.book_name, 
        request.num_recommendations
    )
    
    if 'error' in result:
        raise HTTPException(status_code=404, detail=result['error'])
    
    return result

@app.get("/books/{book_name}/info")
async def get_book_info(book_name: str):
    """Get detailed book information"""
    result = recommender.get_book_info(book_name)
    
    if 'error' in result:
        raise HTTPException(status_code=404, detail=result['error'])
    
    return result

@app.get("/health")
async def health_check():
    """API health check"""
    return {
        "status": "healthy",
        "books_loaded": len(recommender.book_names),
        "model_ready": recommender.model is not None
    }

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

## Response Formats

### Successful Recommendation Response

```json
{
  "input_book": "harry potter and the philosopher's stone",
  "recommendations": [
    {
      "title": "Harry Potter and the Chamber of Secrets",
      "author": "J.K. Rowling",
      "similarity_score": 0.95,
      "image_url": "http://images.amazon.com/images/P/043935806X.01.LZZZZZZZ.jpg",
      "isbn": "043935806X"
    },
    {
      "title": "The Lord of the Rings",
      "author": "J.R.R. Tolkien", 
      "similarity_score": 0.87,
      "image_url": "http://images.amazon.com/images/P/0345339681.01.LZZZZZZZ.jpg",
      "isbn": "0345339681"
    }
  ],
  "total_found": 5
}
```

### Error Response

```json
{
  "error": "Book 'nonexistent book' not found in dataset"
}
```

## Performance Considerations

### Optimization Tips

<AccordionGroup>
  <Accordion title="Model Loading">
    Load models once at startup and reuse them:
    
    ```python path=null start=null
    # Global model loading (recommended for APIs)
    _recommender_instance = None

    def get_recommender():
        global _recommender_instance
        if _recommender_instance is None:
            _recommender_instance = BookRecommender()
        return _recommender_instance
    ```
  </Accordion>

  <Accordion title="Caching">
    Implement caching for frequently requested recommendations:
    
    ```python path=null start=null
    from functools import lru_cache
    import hashlib

    @lru_cache(maxsize=1000)
    def cached_recommendations(book_name: str, num_recs: int):
        """Cache recommendations for popular books"""
        return recommender.get_recommendations(book_name, num_recs)
    ```
  </Accordion>

  <Accordion title="Async Processing">
    Use async processing for better concurrency:
    
    ```python path=null start=null
    import asyncio
    from concurrent.futures import ThreadPoolExecutor

    async def async_recommendations(book_name: str):
        loop = asyncio.get_event_loop()
        with ThreadPoolExecutor() as executor:
            result = await loop.run_in_executor(
                executor, 
                recommender.get_recommendations, 
                book_name
            )
        return result
    ```
  </Accordion>
</AccordionGroup>

## Error Handling

### Common Error Types

1. **Book Not Found**: Requested book is not in the dataset
2. **Model Loading Error**: Model artifacts are missing or corrupted  
3. **Memory Error**: Insufficient memory for processing
4. **Invalid Input**: Malformed or empty book name

### Robust Error Handling

```python path=null start=null
def safe_recommend_book(book_name: str, fallback_to_popular=True):
    """
    Generate recommendations with comprehensive error handling
    """
    try:
        # Validate input
        if not book_name or not book_name.strip():
            raise ValueError("Book name cannot be empty")
        
        # Normalize input
        book_name = book_name.strip().lower()
        
        # Check if book exists
        if book_name not in recommender.book_pivot.index:
            if fallback_to_popular:
                # Return popular books as fallback
                popular_books = (recommender.book_pivot > 0).sum(axis=1).nlargest(5)
                return {
                    'input_book': book_name,
                    'recommendations': popular_books.index.tolist(),
                    'fallback': True,
                    'message': 'Book not found, showing popular recommendations'
                }
            else:
                raise KeyError(f"Book '{book_name}' not found in dataset")
        
        # Generate recommendations
        result = recommender.get_recommendations(book_name)
        return result
        
    except Exception as e:
        return {
            'error': str(e),
            'error_type': type(e).__name__,
            'input_book': book_name
        }
```

The API provides a robust interface for integrating book recommendations into your applications with comprehensive error handling and performance optimizations.